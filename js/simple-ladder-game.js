// Simple Ladder Game - Grid Layout Version
class SimpleLadderGame {
    constructor(container) {
        this.container = container;
        this.slotCount = 0;
        this.topSlots = [];
        this.bottomSlots = [];
        this.connections = [];
        this.ladderStructure = null;
        this.revealedConnections = new Set();
        
        this.colors = [
            '#ff4757', '#3742fa', '#2ed573', '#ffa502', '#ff6348',
            '#70a1ff', '#5352ed', '#ff4081', '#26de81', '#fd79a8',
            '#6c5ce7', '#a29bfe', '#74b9ff', '#0984e3', '#00b894',
            '#00cec9', '#e17055', '#fdcb6e', '#e84393', '#636e72'
        ];
        
        this.init();
    }
    
    init() {
        this.createGameStructure();
        console.log('SimpleLadderGame (Grid Version) initialized');
    }
    
    createGameStructure() {
        this.container.innerHTML = `
            <div class="simple-ladder-container">
                <div class="game-header">
                    <h3>üéØ ÏÇ¨Îã§Î¶¨ÌÉÄÍ∏∞</h3>
                    <div class="game-controls">
                        <button class="btn btn-sm btn-primary reveal-all-btn" disabled>üëÅÔ∏è Î™®Îì† Í≤∞Í≥º Î≥¥Í∏∞</button>
                        <button class="btn btn-sm btn-secondary reset-btn" disabled>üîÑ ÏÉàÎ°ú ÎßåÎì§Í∏∞</button>
                    </div>
                </div>
                
                <div class="ladder-game-area">
                    <!-- Grid items will be generated by JS -->
                </div>
                
                <div class="results-table-section" style="display: none;">
                    <div class="table-header">
                        <h4>üìã Ïó∞Í≤∞ Í≤∞Í≥º</h4>
                        <span class="results-count">(0Í∞ú ÏôÑÎ£å)</span>
                    </div>
                    <div class="results-table-wrapper">
                        <table class="results-table">
                            <thead><tr><th>Ï∞∏Í∞ÄÏûê</th><th>‚Üí</th><th>Í≤∞Í≥º</th></tr></thead>
                            <tbody class="results-tbody"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        `;
        
        this.gameArea = this.container.querySelector('.ladder-game-area');
        this.resultsTableSection = this.container.querySelector('.results-table-section');
        this.resultsTbody = this.container.querySelector('.results-tbody');
        this.resultsCount = this.container.querySelector('.results-count');
        this.revealAllBtn = this.container.querySelector('.reveal-all-btn');
        this.resetBtn = this.container.querySelector('.reset-btn');
        
        this.setupEventListeners();
    }
    
    setupEventListeners() {
        this.revealAllBtn.addEventListener('click', () => this.revealAllConnections());
        this.resetBtn.addEventListener('click', () => this.resetGame());
    }
    
    setupGame(slotCount, topSlots, bottomSlots, connections) {
        this.slotCount = slotCount;
        this.topSlots = [...topSlots];
        this.bottomSlots = [...bottomSlots];
        this.connections = [...connections];
        this.revealedConnections.clear();
        
        this.generateLadderStructure();
        this.renderGridUI();
        
        this.revealAllBtn.disabled = false;
        this.resetBtn.disabled = false;
        
        console.log('Grid game setup complete');
    }

    renderGridUI() {
        this.gameArea.innerHTML = '';
        this.gameArea.style.setProperty('--slot-count', this.slotCount);

        // Add headers
        this.gameArea.innerHTML += `
            <div class="area-label" style="grid-row: 1; grid-column: 1;">Ï∞∏Í∞ÄÏûê</div>
            <div class="area-label" style="grid-row: 1; grid-column: 3;">Í≤∞Í≥º</div>
        `;

        // Create and place participants and results
        for (let i = 0; i < this.slotCount; i++) {
            const row = i + 2; // +2 to account for header row
            // Participant
            const pDiv = document.createElement('div');
            pDiv.className = 'participant-item';
            pDiv.dataset.index = i;
            pDiv.style.gridRow = row;
            pDiv.style.gridColumn = 1;
            pDiv.innerHTML = `<div class="participant-box"><span class="participant-text">${this.topSlots[i]}</span></div>`;
            pDiv.addEventListener('click', () => this.revealConnection(i));
            this.gameArea.appendChild(pDiv);

            // Result
            const rDiv = document.createElement('div');
            rDiv.className = 'result-item';
            rDiv.dataset.index = i;
            rDiv.style.gridRow = row;
            rDiv.style.gridColumn = 3;
            rDiv.innerHTML = `<div class="result-box"><span class="result-text">${this.bottomSlots[i]}</span></div>`;
            this.gameArea.appendChild(rDiv);
        }

        // Create and place the canvas
        const canvasContainer = document.createElement('div');
        canvasContainer.className = 'ladder-area';
        canvasContainer.style.gridRow = `2 / span ${this.slotCount}`;
        canvasContainer.style.gridColumn = 2;
        this.canvas = document.createElement('canvas');
        this.canvas.className = 'ladder-canvas';
        canvasContainer.appendChild(this.canvas);
        this.gameArea.appendChild(canvasContainer);
        this.ctx = this.canvas.getContext('2d');

        // Use a timeout to ensure the grid layout is calculated by the browser
        requestAnimationFrame(() => {
            this.setupCanvas();
            this.drawLadder();
        });
    }
    
    generateLadderStructure() {
        const levels = Math.max(8, this.slotCount * 2);
        this.ladderStructure = { levels, horizontalBars: [] };
        for (let level = 0; level < levels; level++) {
            const bars = [];
            let i = 0;
            while (i < this.slotCount - 1) {
                if (Math.random() < 0.3) {
                    bars.push(i);
                    i += 2;
                } else {
                    i++;
                }
            }
            this.ladderStructure.horizontalBars[level] = bars;
        }
    }
    
    setupCanvas() {
        const containerRect = this.gameArea.querySelector('.ladder-area').getBoundingClientRect();
        this.canvas.width = containerRect.width;
        this.canvas.height = containerRect.height;
    }
    
    getSlotYCoordinates() {
        const participantItems = this.gameArea.querySelectorAll('.participant-item');
        const canvasRect = this.canvas.getBoundingClientRect();
        return Array.from(participantItems).map(item => {
            const itemRect = item.getBoundingClientRect();
            return itemRect.top - canvasRect.top + itemRect.height / 2;
        });
    }

    drawLadder() {
        const ctx = this.ctx;
        const canvas = this.canvas;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const slotYs = this.getSlotYCoordinates();
        if (slotYs.length === 0) return;

        const leftX = 20;
        const rightX = canvas.width - 20;
        const ladderWidth = rightX - leftX;
        const levelWidth = ladderWidth / this.ladderStructure.levels;

        ctx.strokeStyle = '#cccccc';
        ctx.lineWidth = 3;
        ctx.beginPath();
        slotYs.forEach(y => {
            ctx.moveTo(leftX, y);
            ctx.lineTo(rightX, y);
        });
        ctx.stroke();
        
        ctx.strokeStyle = '#bbbbbb';
        ctx.lineWidth = 3;
        for (let level = 0; level < this.ladderStructure.levels; level++) {
            const x = leftX + level * levelWidth;
            const bars = this.ladderStructure.horizontalBars[level];
            for (const barIndex of bars) {
                if (barIndex + 1 < slotYs.length) {
                    ctx.beginPath();
                    ctx.moveTo(x, slotYs[barIndex]);
                    ctx.lineTo(x, slotYs[barIndex + 1]);
                    ctx.stroke();
                }
            }
        }
        console.log('Grid-based ladder drawn');
    }
    
    revealConnection(topIndex) {
        if (this.revealedConnections.has(topIndex)) return;
        
        const bottomIndex = this.connections[topIndex];
        const color = this.colors[topIndex % this.colors.length];
        
        this.revealedConnections.add(topIndex);
        this.drawConnectionPath(topIndex, color);
        
        this.highlightParticipant(topIndex, color);
        this.highlightResult(bottomIndex, color);
        this.updateResultsTable();
    }
    
    drawConnectionPath(topIndex, color) {
        const ctx = this.ctx;
        const slotYs = this.getSlotYCoordinates();
        if (slotYs.length === 0) return;

        const leftX = 20;
        const rightX = this.canvas.width - 20;
        const ladderWidth = rightX - leftX;
        const levelWidth = ladderWidth / this.ladderStructure.levels;

        let currentPosition = topIndex;

        ctx.strokeStyle = color;
        ctx.lineWidth = 5;
        ctx.shadowColor = color;
        ctx.shadowBlur = 10;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        ctx.moveTo(leftX, slotYs[currentPosition]);

        for (let level = 0; level < this.ladderStructure.levels; level++) {
            const x = leftX + level * levelWidth;
            const nextX = leftX + (level + 1) * levelWidth;
            const bars = this.ladderStructure.horizontalBars[level];

            ctx.lineTo(x, slotYs[currentPosition]);

            if (bars.includes(currentPosition)) {
                currentPosition++;
                ctx.lineTo(x, slotYs[currentPosition]);
            } else if (currentPosition > 0 && bars.includes(currentPosition - 1)) {
                currentPosition--;
                ctx.lineTo(x, slotYs[currentPosition]);
            }
            
            ctx.lineTo(nextX, slotYs[currentPosition]);
        }

        ctx.lineTo(rightX, slotYs[currentPosition]);
        ctx.stroke();

        ctx.shadowBlur = 0;
        ctx.lineCap = 'butt';
        ctx.lineJoin = 'miter';
    }
    
    highlightParticipant(index, color) {
        const p = this.gameArea.querySelector(`.participant-item[data-index="${index}"]`);
        if (p) {
            p.classList.add('revealed');
            p.style.setProperty('--connection-color', color);
        }
    }
    
    highlightResult(index, color) {
        const r = this.gameArea.querySelector(`.result-item[data-index="${index}"]`);
        if (r) {
            r.classList.add('revealed');
            r.style.setProperty('--connection-color', color);
        }
    }
    
    updateResultsTable() {
        const count = this.revealedConnections.size;
        this.resultsTableSection.style.display = count > 0 ? 'block' : 'none';
        this.resultsTbody.innerHTML = '';
        
        this.revealedConnections.forEach(topIndex => {
            const bottomIndex = this.connections[topIndex];
            const color = this.colors[topIndex % this.colors.length];
            const row = document.createElement('tr');
            row.innerHTML = `
                <td><span class="result-indicator" style="background-color: ${color}"></span>${this.topSlots[topIndex]}</td>
                <td>‚Üí</td>
                <td><span class="result-indicator" style="background-color: ${color}"></span>${this.bottomSlots[bottomIndex]}</td>
            `;
            this.resultsTbody.appendChild(row);
        });
        
        this.resultsCount.textContent = `(${count}Í∞ú ÏôÑÎ£å)`;
        if (count === this.slotCount) {
            this.revealAllBtn.textContent = '‚úÖ Î™®Îì† Í≤∞Í≥º ÏôÑÎ£å';
            this.revealAllBtn.disabled = true;
        }
    }
    
    revealAllConnections() {
        for (let i = 0; i < this.slotCount; i++) {
            if (!this.revealedConnections.has(i)) {
                setTimeout(() => this.revealConnection(i), i * 100);
            }
        }
    }
    
    resetGame() {
        this.revealedConnections.clear();
        this.generateLadderStructure();
        this.renderGridUI();
        this.resultsTableSection.style.display = 'none';
        this.resultsTbody.innerHTML = '';
        this.resultsCount.textContent = '(0Í∞ú ÏôÑÎ£å)';
        this.revealAllBtn.textContent = 'üëÅÔ∏è Î™®Îì† Í≤∞Í≥º Î≥¥Í∏∞';
        this.revealAllBtn.disabled = false;
        console.log('Game reset');
    }
}

window.SimpleLadderGame = SimpleLadderGame;

const simpleLadderStyles = `
.simple-ladder-container {
    width: 100%; max-width: 1200px; margin: 0 auto; padding: 20px;
    background-color: #f9f9f9; border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.08);
}
.game-header {
    display: flex; justify-content: space-between; align-items: center;
    margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid #eee;
}
.game-header h3 { font-size: 1.5rem; color: #333; margin: 0; }
.game-controls { display: flex; gap: 10px; }

.ladder-game-area {
    display: grid;
    grid-template-columns: minmax(150px, 1.5fr) 3fr minmax(150px, 1.5fr);
    grid-template-rows: auto repeat(var(--slot-count, 1), auto);
    align-items: stretch;
}
.area-label {
    font-weight: bold; color: #555; text-align: center;
    padding: 10px; border-bottom: 1px solid #ddd; margin-bottom: 5px;
}
.participant-item, .result-item {
    display: flex; align-items: center; justify-content: center;
    padding: 5px; cursor: pointer;
    transition: transform 0.2s ease;
}
.participant-item:hover, .result-item:hover { transform: scale(1.02); }
.participant-box, .result-box {
    width: 100%; text-align: center;
    padding: 12px; background-color: #fff; border-radius: 8px;
    border: 1px solid #ddd; box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    transition: all 0.3s ease;
}
.participant-item.revealed .participant-box {
    border-left: 5px solid var(--connection-color, #ccc);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1); font-weight: bold;
}
.result-item.revealed .result-box {
    border-right: 5px solid var(--connection-color, #ccc);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1); font-weight: bold;
}
.ladder-area {
    position: relative;
}
.ladder-canvas {
    position: absolute; top: 0; left: 0;
    width: 100%; height: 100%;
}

.results-table-section { margin-top: 30px; padding-top: 20px; border-top: 2px solid #eee; }
.table-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
.table-header h4 { margin: 0; font-size: 1.2rem; color: #333; }
.results-count { font-size: 0.9rem; color: #777; }
.results-table-wrapper { max-height: 300px; overflow-y: auto; border: 1px solid #ddd; border-radius: 8px; }
.results-table { width: 100%; border-collapse: collapse; text-align: center; }
.results-table th, .results-table td { padding: 12px; border-bottom: 1px solid #eee; }
.results-table th { background-color: #f8f9fa; font-weight: 600; color: #444; }
.results-table tbody tr:last-child td { border-bottom: none; }
.result-indicator {
    display: inline-block; width: 10px; height: 10px;
    border-radius: 50%; margin-right: 8px; vertical-align: middle;
}
`;

const styleSheet = document.createElement("style");
styleSheet.type = "text/css";
styleSheet.innerText = simpleLadderStyles;
document.head.appendChild(styleSheet);
