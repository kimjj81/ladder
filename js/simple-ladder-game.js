// Simple Ladder Game - Grid Layout Version
class SimpleLadderGame {
    constructor(container) {
        this.container = container;
        this.slotCount = 0;
        this.topSlots = [];
        this.bottomSlots = [];
        this.connections = [];
        this.ladderStructure = null;
        this.revealedConnections = new Set();
        
        this.colors = [
            '#ff4757', '#3742fa', '#2ed573', '#ffa502', '#ff6348',
            '#70a1ff', '#5352ed', '#ff4081', '#26de81', '#fd79a8',
            '#6c5ce7', '#a29bfe', '#74b9ff', '#0984e3', '#00b894',
            '#00cec9', '#e17055', '#fdcb6e', '#e84393', '#636e72'
        ];
        
        this.init();
    }
    
    init() {
        this.createGameStructure();
        this.onInitialReset = null; // Callback for full reset
        console.log('SimpleLadderGame (Grid Version) initialized');
    }
    
    createGameStructure() {
        this.container.innerHTML = `
            <div class="simple-ladder-container">
                <div class="game-header">
                    <h3>üéØ ÏÇ¨Îã§Î¶¨ÌÉÄÍ∏∞</h3>
                    <div class="game-controls">
                        <button class="btn btn-sm btn-primary reveal-all-btn" disabled>üëÅÔ∏è Î™®Îì† Í≤∞Í≥º Î≥¥Í∏∞</button>
                        <button class="btn btn-sm btn-secondary reset-btn" disabled>üîÑ ÏÉàÎ°ú ÎßåÎì§Í∏∞</button>
                        <button class="btn btn-sm btn-danger initial-reset-btn">Ï≤òÏùåÏúºÎ°ú</button>
                    </div>
                </div>
                
                <div class="ladder-game-area">
                    <!-- Grid items will be generated by JS -->
                </div>
                
                <div class="results-table-section" style="display: none;">
                    <div class="table-header">
                        <h4>üìã Ïó∞Í≤∞ Í≤∞Í≥º</h4>
                        <span class="results-count">(0Í∞ú ÏôÑÎ£å)</span>
                    </div>
                    <table class="results-table">
                        <thead><tr><th>Ï∞∏Í∞ÄÏûê</th><th>‚Üí</th><th>Í≤∞Í≥º</th></tr></thead>
                        <tbody class="results-tbody"></tbody>
                    </table>
                </div>
            </div>
        `;
        
        this.gameArea = this.container.querySelector('.ladder-game-area');
        this.resultsTableSection = this.container.querySelector('.results-table-section');
        this.resultsTbody = this.container.querySelector('.results-tbody');
        this.resultsCount = this.container.querySelector('.results-count');
        this.revealAllBtn = this.container.querySelector('.reveal-all-btn');
        this.resetBtn = this.container.querySelector('.reset-btn');
        this.initialResetBtn = this.container.querySelector('.initial-reset-btn');
        
        this.setupEventListeners();
    }
    
    setupEventListeners() {
        this.revealAllBtn.addEventListener('click', () => this.revealAllConnections());
        this.resetBtn.addEventListener('click', () => this.resetGame());
        this.initialResetBtn.addEventListener('click', () => {
            if (this.onInitialReset) {
                this.onInitialReset();
            }
        });
    }
    
    setupGame(slotCount, topSlots, bottomSlots, connections, ladderStructure) {
        this.slotCount = slotCount;
        this.topSlots = [...topSlots];
        this.bottomSlots = [...bottomSlots];
        this.connections = [...connections];
        this.ladderStructure = ladderStructure; // Use passed ladderStructure
        this.revealedConnections.clear();
        
        // No need to call generateLadderStructure() here anymore
        
        this.renderGridUI();
        
        this.revealAllBtn.disabled = false;
        this.resetBtn.disabled = false;
        
        console.log('Grid game setup complete');
    }

    renderGridUI() {
        this.gameArea.innerHTML = '';
        this.gameArea.style.setProperty('--slot-count', this.slotCount);

        this.gameArea.innerHTML += `
            <div class="area-label" style="grid-row: 1; grid-column: 1;">Ï∞∏Í∞ÄÏûê</div>
            <div class="area-label" style="grid-row: 1; grid-column: 3;">Í≤∞Í≥º</div>
        `;

        for (let i = 0; i < this.slotCount; i++) {
            const row = i + 2;
            const pDiv = document.createElement('div');
            pDiv.className = 'participant-item';
            pDiv.dataset.index = i;
            pDiv.style.gridRow = row;
            pDiv.style.gridColumn = 1;
            pDiv.innerHTML = `<div class="participant-box"><span class="participant-number">${i + 1}.</span><span class="participant-text">${this.topSlots[i]}</span></div>`;
            pDiv.addEventListener('click', () => this.revealConnection(i));
            this.gameArea.appendChild(pDiv);

            const rDiv = document.createElement('div');
            rDiv.className = 'result-item';
            rDiv.dataset.index = i;
            rDiv.style.gridRow = row;
            rDiv.style.gridColumn = 3;
            rDiv.innerHTML = `<div class="result-box"><span class="result-text">${this.bottomSlots[i]}</span></div>`;
            this.gameArea.appendChild(rDiv);
        }

        const canvasContainer = document.createElement('div');
        canvasContainer.className = 'ladder-area';
        canvasContainer.style.gridRow = `2 / span ${this.slotCount}`;
        canvasContainer.style.gridColumn = 2;
        this.canvas = document.createElement('canvas');
        this.canvas.className = 'ladder-canvas';
        canvasContainer.appendChild(this.canvas);
        this.gameArea.appendChild(canvasContainer);
        this.ctx = this.canvas.getContext('2d');

        requestAnimationFrame(() => {
            this.setupCanvas();
            this.drawLadder();
        });
    }
    
    generateLadderStructure() {
        const levels = Math.max(8, this.slotCount * 2);
        this.ladderStructure = { levels, horizontalBars: [] };
        for (let level = 0; level < levels; level++) {
            const bars = [];
            let i = 0;
            while (i < this.slotCount - 1) {
                if (Math.random() < 0.3) {
                    bars.push(i);
                    i += 2;
                } else {
                    i++;
                }
            }
            this.ladderStructure.horizontalBars[level] = bars;
        }
    }
    
    setupCanvas() {
        const containerRect = this.gameArea.querySelector('.ladder-area').getBoundingClientRect();
        this.canvas.width = containerRect.width;
        this.canvas.height = containerRect.height;
    }
    
    getSlotYCoordinates() {
        const canvas = this.canvas;
        const slotHeight = canvas.height / this.slotCount;
        const slotYs = [];
        for (let i = 0; i < this.slotCount; i++) {
            slotYs.push(slotHeight * (i + 0.5));
        }
        return slotYs;
    }

    drawLadder() {
        const ctx = this.ctx;
        const canvas = this.canvas;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const slotYs = this.getSlotYCoordinates();
        if (slotYs.length === 0) return;

        const leftX = 20;
        const rightX = canvas.width - 20;
        const ladderWidth = rightX - leftX;
        const levelWidth = ladderWidth / this.ladderStructure.numVerticalLevels;

        // Draw horizontal lines (participant/result lines)
        ctx.strokeStyle = '#cccccc';
        ctx.lineWidth = 3;
        ctx.beginPath();
        slotYs.forEach(y => {
            ctx.moveTo(leftX, y);
            ctx.lineTo(rightX, y);
        });
        ctx.stroke();
        
        // Draw vertical bars (rungs)
        ctx.strokeStyle = '#bbbbbb';
        ctx.lineWidth = 3;
        this.ladderStructure.verticalBars.forEach(bar => {
            const x = leftX + (bar.x_level + 0.5) * levelWidth; // Center the bar in its level
            ctx.beginPath();
            ctx.moveTo(x, slotYs[bar.y1_index]);
            ctx.lineTo(x, slotYs[bar.y2_index]);
            ctx.stroke();
        });
    }
    
    revealConnection(topIndex) {
        const bottomIndex = this.connections[topIndex];
        const color = this.colors[topIndex % this.colors.length];

        this.drawLadder(); // Redraw ladder to clear previous paths
        
        const pathsToDraw = new Set(this.revealedConnections);
        pathsToDraw.add(topIndex); // Add current path to be drawn

        // Redraw all revealed paths
        pathsToDraw.forEach(idx => {
            const path = this.ladderStructure.paths.find(p => p.start_y_index === idx);
            if (path) {
                this.drawConnectionPath(path.segments, this.colors[idx % this.colors.length]);
            }
        });

        if (!this.revealedConnections.has(topIndex)) {
            this.revealedConnections.add(topIndex);
            this.highlightParticipant(topIndex, color);
            this.highlightResult(bottomIndex, color, topIndex);
            this.updateResultsTable();
        }
    }
    
    drawConnectionPath(segments, color) {
        const ctx = this.ctx;
        const slotYs = this.getSlotYCoordinates();
        if (slotYs.length === 0) return;

        const leftX = 20;
        const ladderWidth = this.canvas.width - 40;
        const levelWidth = ladderWidth / this.ladderStructure.numVerticalLevels;

        ctx.strokeStyle = color;
        ctx.lineWidth = 5;
        ctx.shadowColor = color;
        ctx.shadowBlur = 10;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();

        segments.forEach((segment, i) => {
            let x1, y1, x2, y2;

            if (segment.type === 'horizontal') {
                x1 = leftX + segment.x1 * levelWidth;
                x2 = leftX + segment.x2 * levelWidth;
                y1 = slotYs[segment.y_index];
                y2 = slotYs[segment.y_index];
            } else { // vertical
                x1 = leftX + segment.x_level * levelWidth;
                x2 = leftX + segment.x_level * levelWidth;
                y1 = slotYs[segment.y1_index];
                y2 = slotYs[segment.y2_index];
            }

            if (i === 0) {
                ctx.moveTo(x1, y1);
            } else {
                ctx.lineTo(x1, y1);
            }
            ctx.lineTo(x2, y2);
        });

        ctx.stroke();

        ctx.shadowBlur = 0;
        ctx.lineCap = 'butt';
        ctx.lineJoin = 'miter';
    }
    
    highlightParticipant(index, color) {
        const p = this.gameArea.querySelector(`.participant-item[data-index="${index}"]`);
        if (p) {
            p.classList.add('revealed');
            p.style.setProperty('--connection-color', color);
        }
    }
    
    highlightResult(index, color, topIndex) {
        const r = this.gameArea.querySelector(`.result-item[data-index="${index}"]`);
        if (r) {
            r.classList.add('revealed');
            r.style.setProperty('--connection-color', color);
            
            const resultBox = r.querySelector('.result-box');
            if (resultBox && !resultBox.querySelector('.participant-badge')) {
                const badge = document.createElement('span');
                badge.className = 'participant-badge';
                badge.textContent = topIndex + 1;
                badge.style.backgroundColor = color;
                resultBox.prepend(badge);
            }
        }
    }
    
    updateResultsTable() {
        const count = this.revealedConnections.size;
        this.resultsTableSection.style.display = count > 0 ? 'block' : 'none';
        this.resultsTbody.innerHTML = '';
        
        this.revealedConnections.forEach(topIndex => {
            const bottomIndex = this.connections[topIndex];
            const color = this.colors[topIndex % this.colors.length];
            const row = document.createElement('tr');
            row.innerHTML = `
                <td><span class="result-indicator" style="background-color: ${color}"></span>${topIndex + 1}. ${this.topSlots[topIndex] || 'Ï∞∏Í∞ÄÏûê ' + (topIndex + 1)}</td>
                <td>‚Üí</td>
                <td><span class="result-indicator" style="background-color: ${color}"></span>${this.bottomSlots[bottomIndex] || 'Í≤∞Í≥º ' + (bottomIndex + 1)}</td>
            `;
            this.resultsTbody.appendChild(row);
        });
        
        this.resultsCount.textContent = `(${count}Í∞ú ÏôÑÎ£å)`;
        if (count === this.slotCount) {
            this.revealAllBtn.textContent = '‚úÖ Î™®Îì† Í≤∞Í≥º ÏôÑÎ£å';
            this.revealAllBtn.disabled = true;
        }
    }
    
    revealAllConnections() {
        for (let i = 0; i < this.slotCount; i++) {
            if (!this.revealedConnections.has(i)) {
                setTimeout(() => this.revealConnection(i), i * 100);
            }
        }
    }
    
    resetGame() {
        this.revealedConnections.clear();
        this.generateLadderStructure();
        this.renderGridUI();
        this.resultsTableSection.style.display = 'none';
        this.resultsTbody.innerHTML = '';
        this.resultsCount.textContent = '(0Í∞ú ÏôÑÎ£å)';
        this.revealAllBtn.textContent = 'üëÅÔ∏è Î™®Îì† Í≤∞Í≥º Î≥¥Í∏∞';
        this.revealAllBtn.disabled = false;
        console.log('Game reset');
    }
}

window.SimpleLadderGame = SimpleLadderGame;

const simpleLadderStyles = `
.simple-ladder-container {
    width: 100%; max-width: 1200px; margin: 0 auto; padding: 20px;
    background-color: #f9f9f9; border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.08);
}
.game-header {
    display: flex; justify-content: space-between; align-items: center;
    margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid #eee;
}
.game-header h3 { font-size: 1.5rem; color: #333; margin: 0; }
.game-controls { display: flex; gap: 10px; }

.ladder-game-area {
    display: grid;
    grid-template-columns: minmax(150px, 1.5fr) 3fr minmax(150px, 1.5fr);
    grid-template-rows: auto repeat(var(--slot-count, 1), 1fr);
    align-items: stretch;
}
.area-label {
    font-weight: bold; color: #555; text-align: center;
    padding: 10px; border-bottom: 1px solid #ddd; margin-bottom: 5px;
}
.participant-item, .result-item {
    display: flex; align-items: center; justify-content: center;
    padding: 5px; cursor: pointer;
    transition: transform 0.2s ease;
}
.participant-item:hover, .result-item:hover { transform: scale(1.02); }
.participant-box, .result-box {
    width: 100%; text-align: center;
    padding: 12px; background-color: #fff; border-radius: 8px;
    border: 1px solid #ddd; box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    position: relative;
}
.participant-number {
    font-size: 0.9em;
    font-weight: bold;
    color: #888;
}
.participant-item.revealed .participant-box {
    border-left: 5px solid var(--connection-color, #ccc);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1); font-weight: bold;
}
.result-item.revealed .result-box {
    border-right: 5px solid var(--connection-color, #ccc);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1); font-weight: bold;
}
.participant-badge {
    position: absolute;
    left: 5px;
    top: 50%;
    transform: translateY(-50%);
    background-color: var(--connection-color);
    color: white;
    font-size: 11px;
    font-weight: bold;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}
.ladder-area {
    position: relative;
}
.ladder-canvas {
    position: absolute; top: 0; left: 0;
    width: 100%; height: 100%;
}

.results-table-section { margin-top: 30px; padding-top: 20px; border-top: 2px solid #eee; }
.table-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
.table-header h4 { margin: 0; font-size: 1.2rem; color: #333; }
.results-count { font-size: 0.9rem; color: #777; }
.results-table { width: 100%; border-collapse: collapse; text-align: center; }
.results-table th, .results-table td { padding: 12px; border-bottom: 1px solid #eee; }
.results-table th { background-color: #f8f9fa; font-weight: 600; color: #444; }
.results-table tbody tr:last-child td { border-bottom: none; }
.result-indicator {
    display: inline-block; width: 10px; height: 10px;
    border-radius: 50%; margin-right: 8px; vertical-align: middle;
}
`;

const styleSheet = document.createElement("style");
styleSheet.type = "text/css";
styleSheet.innerText = simpleLadderStyles;
document.head.appendChild(styleSheet);